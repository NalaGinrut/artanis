<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Learn Scheme in 15 minutes</title>
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="The light-weight and fastest web-framework of Scheme language" />
<meta name="keywords" content="guile tutorial,scheme tutorial,guile scheme,guile,web,web app,framework,scheme language,scheme" />
<link href="css/highlight.css" rel="stylesheet" type="text/css" />
<link href="css/common.css" rel="stylesheet" type="text/css" /></head>
<link rel="icon" type="image/ico" href="favicon.ico" />
<body>
<div id="side">
<div class="wrap">
<h1>Artanis home</h1>
<h2 id="slogan1">A fast monolithic web-framework</h2>
<h2 id="slogan2">of <a id="slogan2" href="scheme.html">Scheme</a></h2>
<ul id="links">
<li><a href="index.html">Home</a></li>
<li><a href="about.html">About</a></li>
<li><a href="http://gnu.org/software/artanis/manual">Documents</a></li>
<li><a href="http://alpha.gnu.org/gnu/artanis/">Download</a></li>
<li class="last"><a href="donate.html">Donate</a></li></ul>
<p id="honor">2013 Lisp in summer projects</p>
<p><a id="honor" href="http://LispInSummerProjects.org/awesome-projects">certificated awesome project</a></p>
<h3 id="the-author">Authored by <a id="the-author" href="http://nalaginrut.com">NalaGinrut</a></h3><a href="http://szdiy.org"><img src="http://wiki.szdiy.org/skins/common/images/szdiy.png" height="100" width="100" /></a>
<br /><a id="counter" href="http://www.hitwebcounter.com/" target="_blank"><img src="http://hitwebcounter.com/counter/counter.php?page=5071476&amp;style=0006&amp;nbdigits=9&amp;type=page&amp;initCount=0" title="counter with different designs" Alt="counter with different designs" border="0" /></a></div></div>
<div id="main" class="home">
<div class="wrap">
<pre><code>
<h3 id="learn-scheme-in-15-minutes">Learn Scheme in 15 minutes</h3>
<pre><tt class="highlight scheme-language"><span class="comment">;; This gives an introduction to Scheme in 15 minutes
</span><span class="comment">;;
</span><span class="comment">;; First make sure you read this text by Peter Norvig:
</span><span class="comment">;; http://norvig.com/21-days.html
</span><span class="comment">;;
</span><span class="comment">;; Then install GNU Guile
</span><span class="comment">;; NOTE: I won&#x27;t encourage using Racket but if you really want,
</span><span class="comment">;;       I still give you some hints in this tutorial. But the
</span><span class="comment">;;       tutorial will base on Guile and RnRs.
</span><span class="comment">;;
</span><span class="comment">;; openSUSE: zypper install guile
</span><span class="comment">;; Debian: apt-get install guile-2.0 (or see your distro instructions)
</span><span class="comment">;; MacOSX: Building Guile 2.0 on the Mac
</span><span class="comment">;;         http://irrealblog.blogspot.hk/2011/03/building-guile-2.html
</span><span class="comment">;; Windows try web: http://repl.it/languages/Scheme
</span><span class="comment">;;
</span><span class="comment">;; More general information can be found at:
</span><span class="comment">;; http://www.gnu.org/software/guile
</span>
<span class="comment">;; Important warning:
</span><span class="comment">;;
</span><span class="comment">;; Going through this tutorial won&#x27;t damage your computer unless
</span><span class="comment">;; you get so angry that you throw it on the floor.  In that case,
</span><span class="comment">;; I hereby decline any responsability.  Have fun!
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 
</span><span class="comment">;; Fire up Scheme:
</span><span class="comment">;; Type &#x27;guile&#x27; for GNU Guile
</span><span class="comment">;; Or just use the browser for web version
</span><span class="comment">;;
</span><span class="comment">;; Now look at the prompt:
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;;
</span><span class="comment">;; Semi-colons start comments anywhere on a line.
</span><span class="comment">;;
</span><span class="comment">;; Scheme programs are made of symbolic expressions (s-exps):
</span><span class="paren1">(<span class="default">+ 2 2</span>)</span>

<span class="comment">;; This symbolic expression reads as &quot;Add 2 to 2&quot;.
</span>
<span class="comment">;; Sexps are enclosed into parentheses, possibly nested:
</span><span class="paren1">(<span class="default">+ 2 <span class="paren2">(<span class="default">+ 1 1</span>)</span></span>)</span>

<span class="comment">;; A symbolic expression contains atoms or other symbolic
</span><span class="comment">;; expressions.  In the above examples, 1 and 2 are atoms,
</span><span class="comment">;; (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.
</span>
<span class="paren1">(<span class="default">+ 3 <span class="paren2">(<span class="default">+ 1 2</span>)</span></span>)</span>
<span class="comment">;; =&gt; 6
</span>
<span class="comment">;; `set!&#x27; stores a value into a variable:
</span><span class="comment">;; Please define my-name first, or you can&#x27;t assign it.
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> my-name <span class="string">&quot;unknown&quot;</span></span>)</span>
<span class="paren1">(<span class="default">set! my-name <span class="string">&quot;NalaGinrut&quot;</span></span>)</span>

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 1. Primitive Datatypes and Operators
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;;; Numbers
</span>9999999999999999999999 <span class="comment">; integers
</span>#b111                  <span class="comment">; binary =&gt; 7
</span>#o111                  <span class="comment">; octal =&gt; 73
</span>#x111                  <span class="comment">; hexadecimal =&gt; 273
</span>3.14                   <span class="comment">; reals
</span>6.02e+23
1/2                    <span class="comment">; rationals
</span>1+2i                   <span class="comment">; complex numbers
</span>
<span class="comment">;; Function application is written (f x y z ...)
</span><span class="comment">;; where f is a function and x, y, z, ... are operands
</span><span class="comment">;; If you want to create a literal list of data, use &#x27; to stop it from
</span><span class="comment">;; being evaluated
</span>&#x27;<span class="paren1">(<span class="default">+ 1 2</span>)</span> <span class="comment">; =&gt; (+ 1 2)
</span><span class="comment">;; Now, some arithmetic operations
</span><span class="paren1">(<span class="default">+ 1 1</span>)</span>  <span class="comment">; =&gt; 2
</span><span class="paren1">(<span class="default">- 8 1</span>)</span>  <span class="comment">; =&gt; 7
</span><span class="paren1">(<span class="default">* 10 2</span>)</span> <span class="comment">; =&gt; 20
</span><span class="paren1">(<span class="default">expt 2 3</span>)</span> <span class="comment">; =&gt; 8
</span><span class="paren1">(<span class="default">quotient 5 2</span>)</span> <span class="comment">; =&gt; 2
</span><span class="paren1">(<span class="default">remainder 5 2</span>)</span> <span class="comment">; =&gt; 1
</span><span class="paren1">(<span class="default">/ 35 5</span>)</span> <span class="comment">; =&gt; 7
</span><span class="paren1">(<span class="default">/ 1 3</span>)</span> <span class="comment">; =&gt; 1/3
</span><span class="paren1">(<span class="default">exact-&gt;inexact 1/3</span>)</span> <span class="comment">; =&gt; 0.3333333333333333
</span><span class="paren1">(<span class="default">+ 1+2i  2-3i</span>)</span> <span class="comment">; =&gt; 3-1i
</span>
<span class="comment">;;; Booleans
</span>#t <span class="comment">; for true
</span>#f <span class="comment">; for false -- any value other than #f is true
</span><span class="paren1">(<span class="default">not #t</span>)</span> <span class="comment">; =&gt; #f
</span><span class="paren1">(<span class="default">and 0 #f <span class="paren2">(<span class="default">error <span class="string">&quot;doesn&#x27;t get here&quot;</span></span>)</span></span>)</span> <span class="comment">; =&gt; #f
</span><span class="paren1">(<span class="default">or #f 0 <span class="paren2">(<span class="default">error <span class="string">&quot;doesn&#x27;t get here&quot;</span></span>)</span></span>)</span>  <span class="comment">; =&gt; 0
</span>
<span class="comment">;;; Characters
</span><span class="comment">;; According to RnRs, characters only have two notations:
</span><span class="comment">;; #\ and #\x
</span><span class="comment">;; Racket support #\u, but it&#x27;s never Scheme.
</span><span class="character">#\A</span> <span class="comment">; =&gt; #\A
</span><span class="character">#\λ</span> <span class="comment">; =&gt; #\λ
</span><span class="character">#\x03BB</span> <span class="comment">; =&gt; #\λ
</span>
<span class="comment">;;; Strings are fixed-length array of characters.
</span><span class="string">&quot;Hello, world!&quot;</span>
<span class="string">&quot;Benjamin </span><span class="string">\&quot;</span><span class="string">Bugsy</span><span class="string">\&quot;</span><span class="string"> Siegel&quot;</span>   <span class="comment">; backslash is an escaping character
</span><span class="string">&quot;Foo</span><span class="string">\t</span><span class="string">bar</span><span class="string">\x</span><span class="string">21</span><span class="string">\a</span><span class="string">\r</span><span class="string">\n</span><span class="string">&quot;</span> <span class="comment">; includes C escapes (only support hex)
</span><span class="comment">;; try to print the above string
</span><span class="comment">;; Printing is pretty easy
</span><span class="paren1">(<span class="default">display <span class="string">&quot;I&#x27;m Guile. Nice to meet you!</span><span class="string">\n</span><span class="string">&quot;</span></span>)</span>
<span class="comment">;; and unicode escapes
</span><span class="string">&quot;</span><span class="string">\u</span><span class="string">004B&quot;</span> <span class="comment">; =&gt; K
</span>
<span class="comment">;; Strings can be added too!
</span><span class="paren1">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> <span class="string">&quot;world!&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hello world!&quot;
</span>
<span class="comment">;; A string can be treated like a list of characters
</span><span class="paren1">(<span class="default">string-ref <span class="string">&quot;Apple&quot;</span> 0</span>)</span> <span class="comment">; =&gt; #\A
</span>
<span class="comment">;; format can be used to format strings:
</span><span class="paren1">(<span class="default">format #t <span class="string">&quot;~a can be ~a&quot;</span> <span class="string">&quot;strings&quot;</span> <span class="string">&quot;formatted&quot;</span></span>)</span>
<span class="comment">;; ==&gt; print &quot;strings can be formatted&quot; on screen
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> str <span class="paren2">(<span class="default">format #f <span class="string">&quot;~a can be ~a&quot;</span> <span class="string">&quot;strings&quot;</span> <span class="string">&quot;formatted&quot;</span></span>)</span></span>)</span>
<span class="comment">;; str was assigned to &quot;strings can be formatted&quot;
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 2. Variables
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; You can create a variable using define
</span><span class="comment">;; a variable name can use any character except: ()[]{}&quot;,&#x27;`;#|\
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> some-var 5</span>)</span>
some-var <span class="comment">; =&gt; 5
</span>
<span class="comment">;; Accessing a previously unassigned variable is an exception
</span><span class="comment">; x ; =&gt; x: undefined ...
</span>
<span class="comment">;; Local binding: `me&#x27; is bound to &quot;Bob&quot; only within the (let ...)
</span><span class="paren1">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">me <span class="string">&quot;Bob&quot;</span></span>)</span></span>)</span>
  <span class="string">&quot;Alice&quot;</span>
  me</span>)</span> 
<span class="comment">;; =&gt; &quot;Bob&quot;
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 3. Structs and Collections
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Record Type (Skip this chapter if you&#x27;re trying web version
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">srfi srfi-9</span>)</span></span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define-record-type</span></i> dog 
  <span class="paren2">(<span class="default">make-dog name breed age</span>)</span>
  dog?
  <span class="paren2">(<span class="default">name dog-name</span>)</span>
  <span class="paren2">(<span class="default">breed dog-breed</span>)</span>
  <span class="paren2">(<span class="default">age dog-age</span>)</span></span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> my-pet
  <span class="paren2">(<span class="default">make-dog <span class="string">&quot;lassie&quot;</span> <span class="string">&quot;collie&quot;</span> 5</span>)</span></span>)</span>
my-pet <span class="comment">; =&gt; #&lt;dog&gt;
</span><span class="paren1">(<span class="default">dog? my-pet</span>)</span> <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">dog-name my-pet</span>)</span> <span class="comment">; =&gt; &quot;lassie&quot;
</span>
<span class="comment">;;; Pairs (immutable)
</span><span class="comment">;; `cons&#x27; constructs pairs, `car&#x27; and `cdr&#x27; extract the first
</span><span class="comment">;; and second elements
</span><span class="paren1">(<span class="default">cons 1 2</span>)</span> <span class="comment">; =&gt; &#x27;(1 . 2)
</span><span class="paren1">(<span class="default">car <span class="paren2">(<span class="default">cons 1 2</span>)</span></span>)</span> <span class="comment">; =&gt; 1
</span><span class="paren1">(<span class="default">cdr <span class="paren2">(<span class="default">cons 1 2</span>)</span></span>)</span> <span class="comment">; =&gt; 2
</span>
<span class="comment">;;; Lists
</span>
<span class="comment">;; Lists are linked-list data structures, made of `cons&#x27; pairs and end
</span><span class="comment">;; with a &#x27;() to mark the end of the list
</span><span class="paren1">(<span class="default">cons 1 <span class="paren2">(<span class="default">cons 2 <span class="paren3">(<span class="default">cons 3 &#x27;<span class="paren4">(<span class="default"></span>)</span></span>)</span></span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(1 2 3)
</span><span class="comment">;; `list&#x27; is a convenience variadic constructor for lists
</span><span class="paren1">(<span class="default">list 1 2 3</span>)</span> <span class="comment">; =&gt; &#x27;(1 2 3)
</span><span class="comment">;; and a quote can also be used for a literal list value
</span>&#x27;<span class="paren1">(<span class="default">1 2 3</span>)</span> <span class="comment">; =&gt; &#x27;(1 2 3)
</span>
<span class="comment">;; Can still use `cons&#x27; to add an item to the beginning of a list
</span><span class="paren1">(<span class="default">cons 4 &#x27;<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(4 1 2 3)
</span>
<span class="comment">;; Use `append&#x27; to add lists together
</span><span class="paren1">(<span class="default">append &#x27;<span class="paren2">(<span class="default">1 2</span>)</span> &#x27;<span class="paren2">(<span class="default">3 4</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(1 2 3 4)
</span>
<span class="comment">;; Lists are a very basic type, so there is a *lot* of functionality for
</span><span class="comment">;; them, a few examples:
</span><span class="comment">;; For Racket users:
</span><span class="paren1">(<span class="default">map add1 &#x27;<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span>          <span class="comment">; =&gt; &#x27;(2 3 4)
</span><span class="comment">;; For Guile users:
</span><span class="paren1">(<span class="default">map 1+ &#x27;<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span>	     <span class="comment">; =&gt; &#x27;(2 3 4)
</span><span class="comment">;; add1 or 1+ is not a standard primitive, so it depends on implementations.
</span>
<span class="paren1">(<span class="default">map + &#x27;<span class="paren2">(<span class="default">1 2 3</span>)</span> &#x27;<span class="paren2">(<span class="default">10 20 30</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(11 22 33)
</span>
<span class="comment">;; filter/count/take/drop are dwell in SRFI-1, so you have to load it first.
</span><span class="comment">;; For Racket users:
</span><span class="paren1">(<span class="default">require srfi/1</span>)</span>
<span class="comment">;; For Guile users:
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">srfi srfi-1</span>)</span></span>)</span>

<span class="paren1">(<span class="default">filter even? &#x27;<span class="paren2">(<span class="default">1 2 3 4</span>)</span></span>)</span>    <span class="comment">; =&gt; &#x27;(2 4)
</span><span class="paren1">(<span class="default">count even? &#x27;<span class="paren2">(<span class="default">1 2 3 4</span>)</span></span>)</span>     <span class="comment">; =&gt; 2
</span><span class="paren1">(<span class="default">take &#x27;<span class="paren2">(<span class="default">1 2 3 4</span>)</span> 2</span>)</span>          <span class="comment">; =&gt; &#x27;(1 2)
</span><span class="paren1">(<span class="default">drop &#x27;<span class="paren2">(<span class="default">1 2 3 4</span>)</span> 2</span>)</span>          <span class="comment">; =&gt; &#x27;(3 4)
</span>
<span class="comment">;;; Vectors
</span>
<span class="comment">;; Vectors are fixed-length arrays
</span>#<span class="paren1">(<span class="default">1 2 3</span>)</span> <span class="comment">; =&gt; &#x27;#(1 2 3)
</span>
<span class="comment">;; Use `vector-append&#x27; to add vectors together
</span><span class="comment">;; NOTE: vector-append is in SRFI-43 which is not supported in Guile-2.0.9
</span><span class="comment">;;       or earlier. And it may not be added in Guile-2.0.10.
</span><span class="comment">;;       But it&#x27;s proposed in R7RS, and there&#x27;s a r7rs branch in Guile upstream.
</span><span class="comment">;;       If your Guile doesn&#x27;t support vector-append, please skip this step.
</span><span class="paren1">(<span class="default">vector-append #<span class="paren2">(<span class="default">1 2 3</span>)</span> #<span class="paren2">(<span class="default">4 5 6</span>)</span></span>)</span> <span class="comment">; =&gt; #(1 2 3 4 5 6)
</span>
<span class="comment">;;; Hashes
</span>
<span class="comment">;; Create mutable hash table
</span><span class="comment">;; For GNU Guile
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> m <span class="paren2">(<span class="default">make-hash-table</span>)</span></span>)</span>
<span class="paren1">(<span class="default">hash-set! m &#x27;a 1</span>)</span>
<span class="paren1">(<span class="default">hash-set! m &#x27;b 2</span>)</span>
<span class="paren1">(<span class="default">hash-set! m &#x27;c 3</span>)</span>

<span class="comment">;; Retrieve a value
</span><span class="paren1">(<span class="default">hash-ref m &#x27;a</span>)</span> <span class="comment">; =&gt; 1
</span>
<span class="comment">;; Retrieving a non-present value is an exception
</span><span class="paren1">(<span class="default">hash-ref m &#x27;d</span>)</span> 
<span class="comment">;; =&gt; #f 
</span>
<span class="comment">;; You can provide a default value for missing keys
</span><span class="paren1">(<span class="default">hash-ref m &#x27;d 0</span>)</span>
<span class="comment">;; =&gt; 0
</span>
<span class="comment">;; Use `hash-remove&#x27; to remove keys (functional too)
</span><span class="paren1">(<span class="default">hash-remove! m &#x27;a</span>)</span> <span class="comment">; =&gt; ((b . 2) (c . 3))
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 3. Functions
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Use `lambda&#x27; to create functions.
</span><span class="comment">;; A function always returns the value of its last expression
</span><span class="paren1">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren2">(<span class="default"></span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span> <span class="comment">; =&gt; #&lt;procedure&gt;
</span>
<span class="comment">;; Use parens to call all functions, including a lambda expression
</span><span class="paren1">(<span class="default"><span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default"></span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span></span>)</span> <span class="comment">; =&gt; &quot;Hello World&quot;
</span><span class="paren1">(<span class="default"><span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">x</span>)</span> <span class="paren3">(<span class="default">+ x x</span>)</span></span>)</span> 5</span>)</span>      <span class="comment">; =&gt; 10
</span>
<span class="comment">;; Assign a function to a var
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> hello-world <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default"></span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">hello-world</span>)</span> <span class="comment">; =&gt; &quot;Hello World&quot;
</span>
<span class="comment">;; You can shorten this using the function definition syntatcic sugar:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">hello-world2</span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span>
<span class="paren1">(<span class="default">hello-world2</span>)</span> <span class="comment">; =&gt; &quot;Hello World&quot;
</span>
<span class="comment">;; The () in the above is the list of arguments for the function
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> hello
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">name</span>)</span>
    <span class="paren3">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> name</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">hello <span class="string">&quot;Steve&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hello Steve&quot;
</span><span class="comment">;; ... or equivalently, using a sugared definition:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">hello2 name</span>)</span>
  <span class="paren2">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> name</span>)</span></span>)</span>

<span class="comment">;; You can have multi-variadic functions too, using `case-lambda&#x27;
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> hello3
  <span class="paren2">(<span class="default">case-lambda
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default"></span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">name</span>)</span> <span class="paren4">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> name</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">hello3 <span class="string">&quot;Jake&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hello Jake&quot;
</span><span class="paren1">(<span class="default">hello3</span>)</span> <span class="comment">; =&gt; &quot;Hello World&quot;
</span><span class="comment">;; ... or specify optional arguments with a default value expression
</span><span class="paren1">(<span class="default"><i><span class="symbol">define*</span></i> <span class="paren2">(<span class="default">hello4 <span class="keyword">#:key</span> <span class="paren3">(<span class="default">name <span class="string">&quot;World&quot;</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> name</span>)</span></span>)</span>

<span class="comment">;; Functions can pack extra arguments up in a list
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">count-args . args</span>)</span>
  <span class="paren2">(<span class="default">format #t <span class="string">&quot;You passed ~a args: ~a&quot;</span> <span class="paren3">(<span class="default">length args</span>)</span> args</span>)</span></span>)</span>
<span class="paren1">(<span class="default">count-args 1 2 3</span>)</span> <span class="comment">; =&gt; &quot;You passed 3 args: (1 2 3)&quot;
</span><span class="comment">;; ... or with the unsugared `lambda&#x27; form:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> count-args2
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> args
    <span class="paren3">(<span class="default">format #t <span class="string">&quot;You passed ~a args: ~a&quot;</span> <span class="paren4">(<span class="default">length args</span>)</span> args</span>)</span></span>)</span></span>)</span>

<span class="comment">;; You can mix regular and packed arguments
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">hello-count name . args</span>)</span>
  <span class="paren2">(<span class="default">format #t <span class="string">&quot;Hello ~a, you passed ~a extra args&quot;</span> name <span class="paren3">(<span class="default">length args</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">hello-count <span class="string">&quot;Finn&quot;</span> 1 2 3</span>)</span>
<span class="comment">; =&gt; &quot;Hello Finn, you passed 3 extra args&quot;
</span><span class="comment">;; ... unsugared:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> hello-count2
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">name . args</span>)</span>
    <span class="paren3">(<span class="default">format #t <span class="string">&quot;Hello ~a, you passed ~a extra args&quot;</span> name <span class="paren4">(<span class="default">length args</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="comment">;; And with keywords
</span><span class="comment">;; the keywords are those like this #:its-name, sometimes you may see
</span><span class="comment">;; :its-name without &#x27;#&#x27; in certain Scheme implementation.
</span><span class="comment">;; NOTE: keywords is not in any Scheme standards like RnRs.
</span><span class="comment">;;       But mainstream Scheme implementation often contains it. 
</span><span class="comment">;;	 This truth also means that different implementation may has
</span><span class="comment">;;	 different result.
</span><span class="comment">;;       The code below will follow Guile situation.
</span><span class="paren1">(<span class="default"><i><span class="symbol">define*</span></i> <span class="paren2">(<span class="default">hello <span class="keyword">#:key</span> <span class="paren3">(<span class="default">name <span class="string">&quot;World&quot;</span></span>)</span> <span class="paren3">(<span class="default">greeting <span class="string">&quot;Hello&quot;</span></span>)</span> . args</span>)</span>
  <span class="paren2">(<span class="default">format #t <span class="string">&quot;~a ~a, ~a extra args~%&quot;</span> greeting name <span class="paren3">(<span class="default">length args</span>)</span></span>)</span></span>)</span>
<span class="comment">;; &#x27;define*&#x27; is similar with &#x27;define&#x27;, but you may use it for defining
</span><span class="comment">;; optional args or using keyword to specify the value to specified argument.
</span><span class="paren1">(<span class="default">hello</span>)</span>                 <span class="comment">; =&gt; &quot;Hello World, 0 extra args&quot;
</span><span class="paren1">(<span class="default">hello 1 2 3</span>)</span>           <span class="comment">; =&gt; &quot;Hello World, 3 extra args&quot;
</span><span class="paren1">(<span class="default">hello <span class="keyword">#:greeting</span> <span class="string">&quot;Hi&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hi World, 2 extra args&quot;
</span><span class="comment">;; NOTE: In Guile, all the keyword-value pairs are countered as the rest args.
</span><span class="comment">;;       It means &#x27;args&#x27; here will be (#:greeting &quot;Hi&quot;), so its length is 2.
</span><span class="comment">;;       If you are in Racket, it&#x27;s different, so the result will be 0.
</span><span class="comment">;;       Because it&#x27;s not defined in RnRs, so it&#x27;s implementation specific.
</span><span class="paren1">(<span class="default">hello <span class="keyword">#:name</span> <span class="string">&quot;Finn&quot;</span> <span class="keyword">#:greeting</span> <span class="string">&quot;Hey&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hey Finn, 4 extra args&quot;
</span><span class="paren1">(<span class="default">hello 1 2 3 <span class="keyword">#:greeting</span> <span class="string">&quot;Hi&quot;</span> <span class="keyword">#:name</span> <span class="string">&quot;Finn&quot;</span> 4 5 6</span>)</span> <span class="comment">; =&gt; &quot;Hi Finn, 10 extra args&quot;
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 4. Equality
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; for numbers use `=&#x27;
</span><span class="paren1">(<span class="default">= 3 3.0</span>)</span> <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">= 2 1</span>)</span> <span class="comment">; =&gt; #f
</span>
<span class="comment">;; for characters use `char=?&#x27;
</span><span class="paren1">(<span class="default">char=? <span class="character">#\c</span> <span class="character">#\c</span></span>)</span> <span class="comment">; =&gt; #t
</span>
<span class="comment">;; for object identity use `eq?&#x27;
</span><span class="comment">;; WARNING: don&#x27;t use `eq?&#x27; on numbers and characters, the reason is very simple:
</span><span class="comment">;;          because RnRs treat this rule as undefined! 
</span><span class="comment">;;(eq? 3 3) ; =&gt; Wrong! it&#x27;s undefined! So it depends on implementation!
</span><span class="comment">;; No matter if you got #t from above, it&#x27;s a wrong usage!!!
</span><span class="comment">;; Should use (= 3 3) or (eqv? 3 3)
</span>
<span class="paren1">(<span class="default">eq? <span class="paren2">(<span class="default">list 3</span>)</span> <span class="paren2">(<span class="default">list 3</span>)</span></span>)</span> <span class="comment">; =&gt; #f
</span><span class="comment">;; Why it&#x27;s #f? Because comparison between objects depends on their head-pointers.
</span><span class="comment">;; These two lists are different objects, and they have different head-pointers.
</span>
<span class="paren1">(<span class="default">eq? &#x27;a &#x27;a</span>)</span> <span class="comment">; =&gt; #t
</span><span class="comment">;; Symbols are the typical objects to compare with their head-pointers
</span>
<span class="comment">;; eqv?
</span><span class="comment">;; The difference between `eqv?&#x27; and `eq&#x27;:
</span><span class="comment">;; You can compare numbers and characters with `eqv?&#x27;
</span><span class="comment">;; When you use `eqv?&#x27; for any objects other than numbers&amp;characters, it&#x27;s the
</span><span class="comment">;; same with `eq?&#x27;.
</span><span class="paren1">(<span class="default">eqv? 3 3</span>)</span>     <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">eqv? <span class="character">#\c</span> <span class="character">#\c</span></span>)</span> <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">eqv? &#x27;a &#x27;a</span>)</span>   <span class="comment">; =&gt; #t
</span>
<span class="comment">;; for collections use `equal?&#x27;
</span><span class="comment">;; `equal?&#x27; will compare all the values in a collections type like record or list.
</span><span class="comment">;; You can compare any objects with `equal?&#x27; safely, but inefficiency.
</span><span class="paren1">(<span class="default">equal? <span class="paren2">(<span class="default">list &#x27;a &#x27;b</span>)</span> <span class="paren2">(<span class="default">list &#x27;a &#x27;b</span>)</span></span>)</span> <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">equal? <span class="paren2">(<span class="default">list &#x27;a &#x27;b</span>)</span> <span class="paren2">(<span class="default">list &#x27;b &#x27;a</span>)</span></span>)</span> <span class="comment">; =&gt; #f
</span>
<span class="comment">;; Choosing proper equal pred for you code, is one of the art in Scheme programming!
</span>
<span class="paren1">(<span class="default">eqv? <span class="string">&quot;abcd&quot;</span> <span class="string">&quot;abcd&quot;</span></span>)</span> <span class="comment">; =&gt; unspecified
</span><span class="comment">;; Obviously, strings are collections type, so...it&#x27;s your EXECISE now!
</span>
<span class="comment">;; Another EXECISE, what&#x27;s the proper &#x27;equal-pred&#x27; for functions?
</span><span class="paren1">(<span class="default">what-to-use? <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">x</span>)</span> <span class="paren3">(<span class="default">1+ x</span>)</span></span>)</span> <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">x</span>)</span> <span class="paren3">(<span class="default">1+ x</span>)</span></span>)</span></span>)</span>

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 5. Control Flow
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;;; Conditionals
</span>
<span class="paren1">(<span class="default"><i><span class="symbol">if</span></i> #t               <span class="comment">; test expression
</span>    <span class="string">&quot;this is true&quot;</span>   <span class="comment">; then expression
</span>    <span class="string">&quot;this is false&quot;</span></span>)</span> <span class="comment">; else expression
</span><span class="comment">; =&gt; &quot;this is true&quot;
</span>
<span class="comment">;; In conditionals, all non-#f values are treated as true
</span><span class="paren1">(<span class="default">member &#x27;Groucho &#x27;<span class="paren2">(<span class="default">Harpo Groucho Zeppo</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(Groucho Zeppo)
</span><span class="paren1">(<span class="default"><i><span class="symbol">if</span></i> <span class="paren2">(<span class="default">member &#x27;Groucho &#x27;<span class="paren3">(<span class="default">Harpo Groucho Zeppo</span>)</span></span>)</span>
    &#x27;yep
    &#x27;nope</span>)</span>
<span class="comment">; =&gt; &#x27;yep
</span>
<span class="comment">;; `cond&#x27; chains a series of tests to select a result
</span><span class="paren1">(<span class="default"><i><span class="symbol">cond</span></i> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">&gt; 2 2</span>)</span> <span class="paren3">(<span class="default">error <span class="string">&quot;wrong!&quot;</span></span>)</span></span>)</span>
      <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">&lt; 2 2</span>)</span> <span class="paren3">(<span class="default">error <span class="string">&quot;wrong again!&quot;</span></span>)</span></span>)</span>
      <span class="paren2">(<span class="default">else &#x27;ok</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;ok
</span>
<span class="comment">;;; Pattern Matching
</span><span class="comment">;; For Racket users:
</span><span class="paren1">(<span class="default">require racket/match</span>)</span> <span class="comment">; use match module
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">fizzbuzz? n</span>)</span>
  <span class="paren2">(<span class="default">match <span class="paren3">(<span class="default">list <span class="paren4">(<span class="default">remainder n 3</span>)</span> <span class="paren4">(<span class="default">remainder n 5</span>)</span></span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">list 0 0</span>)</span> &#x27;fizzbuzz</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">list 0 _</span>)</span> &#x27;fizz</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">list _ 0</span>)</span> &#x27;buzz</span>)</span>
    <span class="paren3">(<span class="default">else #f</span>)</span></span>)</span></span>)</span>

<span class="comment">;; For Guile users:
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">ice-9 match</span>)</span></span>)</span> <span class="comment">; use match module
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">fizzbuzz? n</span>)</span>
  <span class="paren2">(<span class="default">match <span class="paren3">(<span class="default">list <span class="paren4">(<span class="default">remainder n 3</span>)</span> <span class="paren4">(<span class="default">remainder n 5</span>)</span></span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">0 0</span>)</span> &#x27;fizzbuzz</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">0 _</span>)</span> &#x27;fizz</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">_ 0</span>)</span> &#x27;buzz</span>)</span>
    <span class="paren3">(<span class="default">else #f</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="default">fizzbuzz? 15</span>)</span> <span class="comment">; =&gt; &#x27;fizzbuzz
</span><span class="paren1">(<span class="default">fizzbuzz? 37</span>)</span> <span class="comment">; =&gt; #f
</span>
<span class="comment">;;; Loops
</span>
<span class="comment">;; Looping can be done through (tail-) recursion
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">lp i</span>)</span>
  <span class="paren2">(<span class="default">when <span class="paren3">(<span class="default">&lt; i 10</span>)</span>
    <span class="paren3">(<span class="default">format #t <span class="string">&quot;i=~a</span><span class="string">\n</span><span class="string">&quot;</span> i</span>)</span>
    <span class="paren3">(<span class="default">lp <span class="paren4">(<span class="default">1+ i</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">lp 5</span>)</span> <span class="comment">; =&gt; i=5, i=6, ...
</span>
<span class="comment">;; Similarly, with a named let
</span><span class="paren1">(<span class="default"><i><span class="symbol">let</span></i> lp <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">i 0</span>)</span></span>)</span>
  <span class="paren2">(<span class="default">when <span class="paren3">(<span class="default">&lt; i 10</span>)</span>
    <span class="paren3">(<span class="default">format #t <span class="string">&quot;i=~a</span><span class="string">\n</span><span class="string">&quot;</span> i</span>)</span>
    <span class="paren3">(<span class="default">lp <span class="paren4">(<span class="default">1+ i</span>)</span></span>)</span></span>)</span></span>)</span> <span class="comment">; =&gt; i=0, i=1, ...
</span>
<span class="comment">;; how to get a range? just like range(0, 9)?
</span><span class="comment">;; the original &#x27;iota&#x27; only accept one para
</span><span class="paren1">(<span class="default">iota 10</span>)</span> <span class="comment">; ==&gt; (0 1 2 3 4 5 6 7 8 9)
</span><span class="comment">;; the &#x27;iota&#x27; in srfi-1 was extended 
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">srfi srfi-1</span>)</span></span>)</span>
<span class="comment">;; #&lt;procedure iota (count #:optional start step)&gt;
</span><span class="paren1">(<span class="default">iota 5 10</span>)</span> <span class="comment">; =&gt; (10 11 12 13 14) 
</span><span class="comment">;; means from 10 count 5 times, each step +1 (plus one is default)
</span><span class="paren1">(<span class="default">iota 5 10 2</span>)</span> <span class="comment">; =&gt; (10 12 14 16 18)
</span><span class="comment">;; from 10 count 5 times, each step +2
</span><span class="comment">;; If you need a Python like range(5, 10) ==&gt; (5 6 7 8 9), try:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">range from to</span>)</span> <span class="paren2">(<span class="default">map <span class="paren3">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren4">(<span class="default">x</span>)</span> <span class="paren4">(<span class="default">+ from x</span>)</span></span>)</span> <span class="paren3">(<span class="default">iota <span class="paren4">(<span class="default">- to from</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; EXECISE: you may find this &#x27;range&#x27; implementation is not so good,
</span><span class="comment">;;          please optimize it if you can.
</span><span class="paren1">(<span class="default">range 5 10</span>)</span> <span class="comment">; =&gt; (5 6 7 8 9)
</span>
<span class="comment">;; how to do iteration?
</span><span class="paren1">(<span class="default">for-each display &#x27;<span class="paren2">(<span class="default">1 2 3 4 5</span>)</span></span>)</span>
<span class="comment">;; =&gt; 12345
</span><span class="paren1">(<span class="default">for-each <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">i</span>)</span> <span class="paren3">(<span class="default">format #t <span class="string">&quot;i=~a</span><span class="string">\n</span><span class="string">&quot;</span> i</span>)</span></span>)</span>
          <span class="paren2">(<span class="default">iota 10</span>)</span></span>)</span> <span class="comment">; =&gt; i=0, i=1, ...
</span><span class="paren1">(<span class="default">for-each <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">i</span>)</span> <span class="paren3">(<span class="default">format #t <span class="string">&quot;i=~a</span><span class="string">\n</span><span class="string">&quot;</span> i</span>)</span></span>)</span>
          <span class="paren2">(<span class="default">range 5 10</span>)</span></span>)</span> <span class="comment">; =&gt; i=5, i=6, ...
</span>
<span class="comment">;;; Iteration Over Other Sequences
</span><span class="comment">;; `for&#x27; allows iteration over many other kinds of sequences:
</span><span class="comment">;; lists, vectors, strings, sets, hash tables, etc...
</span><span class="paren1">(<span class="default">for-each display &#x27;<span class="paren2">(<span class="default">l i s t</span>)</span></span>)</span>
<span class="comment">;; =&gt; list
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> vector-for-each <span class="paren2">(<span class="default">@ <span class="paren3">(<span class="default">rnrs</span>)</span> vector-for-each</span>)</span></span>)</span>
<span class="comment">;; export vector-for-each from rnrs only
</span><span class="paren1">(<span class="default">vector-for-each display #<span class="paren2">(<span class="default">v e c t o r</span>)</span></span>)</span>
<span class="comment">;; =&gt; vector
</span><span class="paren1">(<span class="default">string-for-each display <span class="string">&quot;string&quot;</span></span>)</span>
<span class="comment">;; =&gt; string
</span><span class="comment">;;; More Iterations
</span><span class="paren1">(<span class="default">do <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">i 10 <span class="paren4">(<span class="default">1+ i</span>)</span></span>)</span> <span class="paren3">(<span class="default">j &#x27;<span class="paren4">(<span class="default">x y z</span>)</span> <span class="paren4">(<span class="default">cdr j</span>)</span></span>)</span></span>)</span> 
    <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">null? j</span>)</span></span>)</span> <span class="comment">; if j is &#x27;(), just end the loop
</span>  <span class="paren2">(<span class="default">format #t <span class="string">&quot;~a:~a &quot;</span> i <span class="paren3">(<span class="default">car j</span>)</span></span>)</span></span>)</span>
<span class="comment">; =&gt; 0:x 1:y 2:z
</span>
<span class="comment">;;; Exceptions
</span>
<span class="comment">;; To catch exceptions, use the &#x27;catch&#x27; form
</span><span class="paren1">(<span class="default"><i><span class="symbol">catch</span></i> &#x27;my-error 
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default"></span>)</span> <span class="paren3">(<span class="default"><i><span class="symbol">throw</span></i> &#x27;my-error</span>)</span></span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> e <span class="paren3">(<span class="default">display <span class="string">&quot;oh~my error!</span><span class="string">\n</span><span class="string">&quot;</span></span>)</span></span>)</span></span>)</span>
<span class="comment">; =&gt; oh~my error!
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 6. Mutation
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Use `set!&#x27; to assign a new value to an existing variable
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> n 5</span>)</span>
<span class="paren1">(<span class="default">set! n <span class="paren2">(<span class="default">1+ n</span>)</span></span>)</span>
n <span class="comment">; =&gt; 6
</span>
<span class="comment">;; Use fluid for explicitly mutable values
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> n* <span class="paren2">(<span class="default">make-fluid 5</span>)</span></span>)</span>
<span class="paren1">(<span class="default">fluid-set! n* <span class="paren2">(<span class="default">1+ <span class="paren3">(<span class="default">fluid-ref n*</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">fluid-ref n*</span>)</span> <span class="comment">; =&gt; 6
</span>
<span class="comment">;; Many Guile datatypes are immutable (pairs, lists, etc), some come in
</span><span class="comment">;; both mutable and immutable flavors (strings, vectors, hash tables,
</span><span class="comment">;; etc...)
</span>
<span class="comment">;; Use `vector&#x27; or `make-vector&#x27; to create mutable vectors
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> vec <span class="paren2">(<span class="default">vector 2 2 3 4</span>)</span></span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> wall <span class="paren2">(<span class="default">make-vector 100 &#x27;bottle-of-beer</span>)</span></span>)</span>
<span class="comment">;; Use vector-set! to update a slot
</span><span class="paren1">(<span class="default">vector-set! vec 0 1</span>)</span>
<span class="paren1">(<span class="default">vector-set! wall 99 &#x27;down</span>)</span>
vec <span class="comment">; =&gt; #(1 2 3 4)
</span>
<span class="comment">;; Create an empty mutable hash table and manipulate it
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> m3 <span class="paren2">(<span class="default">make-hash-table</span>)</span></span>)</span>
<span class="paren1">(<span class="default">hash-set! m3 &#x27;a 1</span>)</span>
<span class="paren1">(<span class="default">hash-set! m3 &#x27;b 2</span>)</span>
<span class="paren1">(<span class="default">hash-set! m3 &#x27;c 3</span>)</span>
<span class="paren1">(<span class="default">hash-ref m3 &#x27;a</span>)</span>   <span class="comment">; =&gt; 1
</span><span class="paren1">(<span class="default">hash-ref m3 &#x27;d 0</span>)</span> <span class="comment">; =&gt; 0
</span><span class="paren1">(<span class="default">hash-remove! m3 &#x27;a</span>)</span>

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 7. Modules
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Modules let you organize code into multiple files and reusable
</span><span class="comment">;; libraries; Make sure put all the module code in one file, since 
</span><span class="comment">;; the modules split as files. And the module name should be same 
</span><span class="comment">;; with the filename, say, module named (my-cake) is &#x27;my-cake.scm&#x27;,
</span><span class="comment">;; and module named (mods my-cake) is &#x27;mods/my-cake.scm&#x27;,
</span><span class="comment">;; (mods submods my-cake) ==&gt; &#x27;mods/submods/my-cake.scm&#x27;.
</span><span class="comment">;; ---begin my-cake.scm---
</span><span class="paren1">(<span class="default"><i><span class="symbol">define-module</span></i> <span class="paren2">(<span class="default">my-cake</span>)</span> <span class="comment">; define a `cake&#x27; module based on racket/base
</span>  <span class="keyword">#:use-module</span> <span class="paren2">(<span class="default">ice-9 format</span>)</span> <span class="comment">; the pre-requisition of current module
</span>  <span class="keyword">#:export</span> <span class="paren2">(<span class="default">print-cake</span>)</span></span>)</span> <span class="comment">; function exported by the module
</span>
  <span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">show fmt n ch</span>)</span> <span class="comment">; internal function
</span>    <span class="paren2">(<span class="default">format #t fmt <span class="paren3">(<span class="default">make-string n ch</span>)</span></span>)</span>
    <span class="paren2">(<span class="default">newline</span>)</span></span>)</span>

  <span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">print-cake n</span>)</span>
    <span class="paren2">(<span class="default">show <span class="string">&quot;   ~a   &quot;</span> n <span class="character">#\.</span></span>)</span>
    <span class="paren2">(<span class="default">show <span class="string">&quot; .-~a-. &quot;</span> n <span class="character">#\|</span></span>)</span>
    <span class="paren2">(<span class="default">show <span class="string">&quot; | ~a | &quot;</span> n <span class="character">#\space</span></span>)</span>
    <span class="paren2">(<span class="default">show <span class="string">&quot;---~a---&quot;</span> n <span class="character">#\-</span></span>)</span></span>)</span>
<span class="comment">;; --end my-cake.scm---
</span>
<span class="comment">;; Be sure that the path of &#x27;my-cake.scm&#x27; is in your current 
</span><span class="comment">;; %load-path list. Use `use-modules&#x27; to get all `provide&#x27;d names 
</span><span class="comment">;; from a module.
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">my-cake</span>)</span></span>)</span> <span class="comment">; the &#x27; is for a local submodule
</span><span class="paren1">(<span class="default">print-cake 3</span>)</span>
<span class="comment">; (show &quot;~a&quot; 1 #\A) ; =&gt; error, `show&#x27; was not exported
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 8. Classes and Objects
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; TODO
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="comment">;; 9. Macros
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Macros let you extend the syntax of the language
</span>
<span class="comment">;; Let&#x27;s add a while loop
</span><span class="paren1">(<span class="default"><i><span class="symbol">define-syntax-rule</span></i> <span class="paren2">(<span class="default">while condition body ...</span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">let</span></i> <i><span class="symbol">loop</span></i> <span class="paren3">(<span class="default"></span>)</span>
    <span class="paren3">(<span class="default">when condition
      body ...
      <span class="paren4">(<span class="default"><i><span class="symbol">loop</span></i></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">i 0</span>)</span></span>)</span>
  <span class="paren2">(<span class="default">while <span class="paren3">(<span class="default">&lt; i  10</span>)</span>
    <span class="paren3">(<span class="default">display i</span>)</span>
    <span class="paren3">(<span class="default">set! i <span class="paren4">(<span class="default">1+ i</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="comment">;; Macros are hygienic, you cannot clobber existing variables!
</span><span class="paren1">(<span class="default"><i><span class="symbol">define-syntax-rule</span></i> <span class="paren2">(<span class="default">swap! x y</span>)</span> <span class="comment">; -! is idomatic for mutation
</span>  <span class="paren2">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">tmp x</span>)</span></span>)</span>
    <span class="paren3">(<span class="default">set! x y</span>)</span>
    <span class="paren3">(<span class="default">set! y tmp</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> tmp 1</span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> a 2</span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> b 3</span>)</span>
<span class="paren1">(<span class="default">swap! a b</span>)</span>
<span class="paren1">(<span class="default">format #t <span class="string">&quot;tmp = ~a; a = ~a; b = ~a</span><span class="string">\n</span><span class="string">&quot;</span> tmp a b</span>)</span> <span class="comment">; tmp is unaffected
</span>
<span class="comment">;; But they are still code transformations, for example:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define-syntax-rule</span></i> <span class="paren2">(<span class="default">bad-while condition body ...</span>)</span>
  <span class="paren2">(<span class="default">when condition
    body ...
    <span class="paren3">(<span class="default">bad-while condition body ...</span>)</span></span>)</span></span>)</span>
<span class="comment">;; this macro is broken: it generates infinite code, if you try to use
</span><span class="comment">;; it, the compiler will get in an infinite loop
</span></tt></pre>
<p>Happy Hacking!</p></code></pre></div>
<p class="foot up"><a href="http://gnu.org/software/artanis">Copyright  2015 Free Software Foundation, Inc.</a> Source: <a href="http://github.com/NalaGinrut/artanis">Artanis </a>powered by <a href="http://www.gnu.org/software/guile/">GNU Guile </a>This page is Powered by <a href="http://wiki.call-cc.org/eggref/4/hyde">Hyde of Chicken Scheme</a></p></div><a id="forkme" href="http://github.com/NalaGinrut/artanis/">Fork me on Github</a></body></html>